{"title":"Sequencing (Single Seller)","markdown":{"yaml":{"title":"Sequencing (Single Seller)","author":"Chhouk Phalthunin, Hok Lyhour, Hun Sopheak","format":{"html":{"theme":"cosmo","mathjax":true,"css":"styles.css","toc":true,"toc-depth":2,"code-fold":true,"code-summary":"Show code"}},"mermaid":{"theme":"default"}},"headingText":"[1. **Introduction**]{style=\"color:#990000;\"}","containsRefs":false,"markdown":"\n\n\nThis project studies the sequencing of customer orders for a single seller in an e-commerce platform. We compare three classical single-machine scheduling rules, **First Come First Served (FCFS), Shortest Processing Time (SPT), and Earliest Due Date (EDD), and evaluate their effects on waiting time and tardiness.**\n\nUsing the [Brazilian E-Commerce (Olist) dataset](https://www.kaggle.com/datasets/olistbr/brazilian-ecommerce), we simulate order processing for each seller independently and develop an interactive system that allows sellers to input their seller ID and examine the resulting order sequences and performance metrics under each rule.\n\n::: callout-note\nMandatory Tables\n\n-   olist_orders_dataset\n-   olist_order_items_dataset\n:::\n\n# [**2. Objective**]{style=\"color:#990000;\"}\n\nThe main objectives of this project are to:\n\n1.  Model the order processing of a single seller as a single-machine scheduling problem.\n\n2.  Apply and compare three classical sequencing rules: First Come First Served (FCFS), Shortest Processing Time (SPT), and Earliest Due Date (EDD).\n\n3.  Evaluate the impact of each sequencing rule on key performance measures, including waiting time and tardiness.\n\n4.  Use real transaction data from the Brazilian E-Commerce (Olist) dataset to simulate order processing under each rule.\n\n5.  Develop an interactive scheduling system that allows sellers to input their seller ID and analyze order sequences and performance metrics.\n\n# [**3. Road Map**]{style=\"color:#990000;\"}\n\n```{mermaid}\nflowchart LR\n    A(**Data Preprocessing**<br/>Clean data<br/>Understand features) --> B(**Seller Separation**<br/>Group orders by seller<br/>Treat each seller independently)\n    B --> C(**Sequencing Models**<br/>FCFS<br/>SPT<br/>EDD) \n    C --> D(**Interactive System**<br/>Input seller ID<br/>View sequences & metrics)\n```\n\n# [**4. Methodolgy**]{style=\"color:#990000;\"}\n\n## [**4.1 Data Cleaning and Data Preprocessing**]{style=\"color:#990000;\"}\n\n### 4.1.1. Import Important Libraries and Load Data\n\n```{python}\n#| code-fold: true\nimport pandas as pd\nimport numpy as np\nimport plotly.graph_objects as go\nfrom plotly.subplots import make_subplots \n```\n\n```{python}\n#| code-fold: true\n#| code-summary: load order items data\n#| code-line-numbers: true\norder_items = pd.read_csv(\"olist_order_items_dataset.csv\")\norder_items.head()\n```\n\n```{python}\n#| code-fold: true\n#| code-line-numbers: true\norders = pd.read_csv(\"olist_orders_dataset.csv\")\norders.head()\n```\n\n### 4.1.2. Features Understanding\n\nThe following tables summarize the main features used from the olist_order_items_dataset and olist_orders_dataset, including their descriptions and data types. Only variables relevant to order sequencing and scheduling are considered in this project.\n\n```{python}\n#| code-fold: true\n#| code-summary: load orders data\n#| code-line-numbers: true\n\norder_items_features = pd.DataFrame({\n    \"Feature\": [\n        \"order_id\",\n        \"order_item_id\",\n        \"product_id\",\n        \"seller_id\",\n        \"shipping_limit_date\",\n        \"price\",\n        \"freight_value\"\n    ],\n    \"Description\": [\n        \"Unique identifier of an order\",\n        \"Sequential number of the item within the order\",\n        \"Unique identifier of the product\",\n        \"Unique identifier of the seller\",\n        \"Deadline for the seller to ship the item\",\n        \"Price of the item\",\n        \"Shipping cost of the item\"\n    ],\n    \"Data Type\": [\n        \"Categorical (string)\",\n        \"Integer\",\n        \"Categorical (string)\",\n        \"Categorical (string)\",\n        \"Datetime\",\n        \"Numeric (float)\",\n        \"Numeric (float)\"\n    ]\n})\n\norder_items_features\n\n```\n\nThe following tables summarize the main features used from the olist_order_items_dataset and olist_orders_dataset, including their descriptions and data types. Only variables relevant to order sequencing and scheduling are considered in this project.\n\n```{python}\n#| code-fold: true\n#| code-line-numbers: true\n\norders_features = pd.DataFrame({\n    \"Feature\": [\n        \"order_id\",\n        \"customer_id\",\n        \"order_status\",\n        \"order_purchase_timestamp\",\n        \"order_approved_at\",\n        \"order_delivered_carrier_date\",\n        \"order_delivered_customer_date\",\n        \"order_estimated_delivery_date\"\n    ],\n    \"Description\": [\n        \"Unique identifier of an order\",\n        \"Unique identifier of the customer\",\n        \"Current status of the order\",\n        \"Time when the customer placed the order\",\n        \"Time when payment was approved\",\n        \"Time when order was handed to the carrier\",\n        \"Time when order was delivered to customer\",\n        \"Estimated delivery deadline\"\n    ],\n    \"Data Type\": [\n        \"Categorical (string)\",\n        \"Categorical (string)\",\n        \"Categorical\",\n        \"Datetime\",\n        \"Datetime\",\n        \"Datetime\",\n        \"Datetime\",\n        \"Datetime\"\n    ]\n})\n\norders_features\n```\n\nFrom the available features, only variables that directly contribute to modeling a single-machine scheduling problem are retained. Specifically, **seller_id** is used to define independent seller systems, **order_approved_at** represents the **arrival time of an order**, and **order_estimated_delivery_date** serves as the due date (deadline), and the number of items per order is used as a proxy for processing time. Other features are excluded as they do not influence sequencing decisions or scheduling priorities.\n\n## [**4.2. Seller Separation**]{style=\"color:#990000;\"}\n\nThe Olist dataset contains multiple sellers, each operating independently. To model order processing as a single-machine scheduling problem, sellers are first identified and separated so that each seller’s orders form an independent scheduling system.\n\n```{python}\n#| code-fold: true\n#| code-summary: load orders data\n#| code-line-numbers: true\nnum_sellers = order_items[\"seller_id\"].nunique()\nprint(f\"There are a total of {num_sellers} unique sellers.\")\n```\n\nTo analyze order flow at the seller level, orders are grouped by seller_id. For each seller, a scheduling table is constructed where each order is treated as one job. The order purchase time is defined as the arrival time, the estimated delivery date is used as the due date, and the number of items in an order is used as a proxy for processing time.\n\nThe following function generates a scheduling table for any selected seller:\n\n```{python}\n#| code-fold: true\n#| code-summary: load orders data\n#| code-line-numbers: true\n\ndef create_scheduling_table(seller_id, order_items, orders):\n    seller_items = order_items[order_items[\"seller_id\"] == seller_id]\n\n    scheduling_table = (\n        seller_items\n        .merge(orders, on=\"order_id\")\n        .groupby(\"order_id\")\n        .agg(\n            arrival_time=(\"order_approved_at\", \"first\"),\n            due_date=(\"order_estimated_delivery_date\", \"first\"),\n            processing_time=(\"order_item_id\", \"count\")\n        )\n        .reset_index()\n    )\n    return scheduling_table\n\n```\n\nTo ensure meaningful sequencing analysis, sellers are ranked based on the total number of items ordered. This allows the selection of sellers with sufficient order volume.\n\n```{python}\n#| code-fold: true\n#| code-summary: rank sellers by number of items\norders_per_seller_df = (\norder_items\n.groupby(\"seller_id\")\n.size()\n.reset_index(name=\"number_of_items\")\n.sort_values(by=\"number_of_items\", ascending=False)\n)\n\norders_per_seller_df.head()\n```\n\n## [**4.3. Data Cleaning**]{style=\"color:#990000;\"}\n\nBefore applying the sequencing models, the dataset is checked for missing values and data type consistency. In particular, timestamp variables must be converted to datetime format to ensure accurate computation of arrival times, due dates, waiting times, and tardiness.\n\n<<<<<<< HEAD\n### [**4.3.1 Check for Missing Values**]{style=\"color:#990000;\"}\n=======\n[4.3. Data Cleaning]{style=\"color:#990000;\"}\n\nBefore applying the sequencing models, the dataset is checked for missing values and data type consistency. In particular, timestamp variables must be converted to datetime format to ensure accurate computation of arrival times, due dates, waiting times, and tardiness.\n\n4.3.1 Check for Missing Values\n>>>>>>> 73229e2 (Update sequencing_single_seller.qmd and generated site)\n\nThe following code checks for missing values in both datasets.\n\n```{python}\n#| code-fold: true\n#| code-summary: Data Info\n#| code-line-numbers: true\norder_items.isnull().sum()\n```\n\n```{python}\n#| code-fold: true\n#| code-summary: Data Info\n#| code-line-numbers: true\norders.isnull().sum()\n```\n\n```{python}\n#| code-fold: true\n#| code-summary: Removing Missing Values\n#| code-line-numbers: true\n#| \nvalid_orders = orders[orders[\"order_approved_at\"].notna()]\n# Keep only valid orders in orders table\norders_clean = valid_orders.copy()\n\n# Keep only order_items belonging to valid orders\norder_items_clean = order_items[\n    order_items[\"order_id\"].isin(orders_clean[\"order_id\"])\n]\norders_clean = orders_clean.reset_index(drop=True)\norder_items_clean = order_items_clean.reset_index(drop=True)\n\n```\n\n```{python}\n\n#| code-fold: true\n#| code-summary: Data Info\n#| code-line-numbers: true\norders = orders_clean\norder_items = order_items_clean\n```\n\nMoreover, to perform time-based calculations, all relevant date columns are converted to datetime format.\n\n```{python}\n#| code-fold: true\n#| code-summary: Convert to datetime\n#| code-line-numbers: true\norder_items[\"shipping_limit_date\"] = pd.to_datetime(\norder_items[\"shipping_limit_date\"]\n)\n```\n\n```{python}\n#| code-fold: true\n#| code-summary: convert orders date columns\ndate_columns = [\n\"order_purchase_timestamp\",\n\"order_approved_at\",\n\"order_delivered_carrier_date\",\n\"order_delivered_customer_date\",\n\"order_estimated_delivery_date\"\n]\n\nfor col in date_columns:\n    orders[col] = pd.to_datetime(orders[col])\n```\n\nAfter conversion, data types are verified to ensure correctness.\n\n```{python}\n#| code-fold: true\n#| code-summary: verify data types\norders.dtypes\n```\n\n```{python}\n#| code-fold: true\n#| code-summary: verify data types\norder_items.dtypes\n```\n\nAll timestamp variables are now stored as datetime objects, allowing accurate computation of arrival times, due dates, and scheduling performance metrics.\n\n## [**4.4. Sequencing Model Formulation**]{style=\"color:#990000;\"}\n\n### [**4.4.1. Scheduling Variables and Performance Measures**]{style=\"color:#990000;\"}\n\nIn this project, order processing for each seller is modeled as a **single-machine scheduling problem**. Each order is treated as a job that must be processed by a single server (the seller), with **no preemption** and **only one job processed at a time**.\n\n### Scheduling Variables\n\nFor each order (job) $i$, the following scheduling variables are defined:\n\n-   **Arrival time ($r_i$)**\\\n    The time at which order $i$ becomes available for processing.\\\n    In this study, $r_i$ is defined as the **order_approved_at**.\n\n-   **Processing time ($p_i$)**\\\n    The time required to complete order $i$.\\\n    Since actual handling times are unavailable, $p_i$ is approximated by the **number of items in the order**.\n\n-   **Due date ($d_i$)**\\\n    The promised completion time for order $i$.\\\n    This is defined as the **estimated delivery date** provided by the platform.\n\n-   **Sequence (π)**\\\n    An ordered list of jobs that specifies the processing order, determined by a sequencing rule such as **FCFS**, **SPT**, or **EDD**.\n\n### Performance Measures\n\nTo evaluate the effectiveness of each sequencing rule, the following standard performance measures are used:\n\n-   **Start time ($S_i$)**\\\n    The time at which processing of order $i$ begins.\n\n-   **Completion time ($C_i$)**\\\n    The time at which processing of order $i$ finishes.\n\n-   **Waiting time ($W_i$)**\\\n    The amount of time order $i$ waits before processing:\n\n    $$\n    W_i = S_i - r_i\n    $$\n\n-   **Tardiness ($T_i$)**\\\n    The amount by which order *i* is completed after its due date:\n\n    $$\n    T_i = \\max(0, C_i - d_i)\n    $$\n\nThese performance measures are commonly used in single-machine scheduling problems and allow for a quantitative comparison of different sequencing rules in terms of service efficiency and deadline compliance.\n\n### [**4.4.2 Schedule Simulation Procedure**]{style=\"color:#990000;\"}\n\nOnce a processing sequence is determined by a sequencing rule, the order processing schedule is simulated using standard single-machine scheduling logic. Given a fixed sequence of jobs, start times, completion times, waiting times, and tardiness values are computed sequentially.\n\nLet jobs be indexed according to the chosen sequence. For each order (job) $i$, processing begins either when the previous job is completed or when the order arrives, whichever occurs later. The start time is therefore defined as:\n\n$$\nS_i = \\max(C_{i-1}, r_i)\n$$\n\nThe completion time of job $i$ is then given by:\n\n$$\nC_i = S_i + p_i\n$$\n\nUsing the computed start and completion times, performance measures are obtained as follows. The waiting time of job $i$ is defined as the difference between its start time and arrival time:\n\n$$\nW_i = S_i - r_i\n$$\n\nThe tardiness of job $i$ measures the extent to which completion exceeds the due date and is defined as:\n\n$$\nT_i = \\max(0, C_i - d_i)\n$$\n\nThis simulation procedure is applied uniformly across all sequencing rules. By holding the simulation logic constant and varying only the job sequence, the impact of different sequencing rules on waiting time and tardiness can be fairly and consistently compared.\n\n```{python}\n#| code-fold: false\n#| code-summary: simulate schedule\n#| code-line-numbers: true\ndef simulate_schedule_and_metrics(df):\n    df = df.copy()\n    df[\"start_time\"] = pd.NaT\n    df[\"completion_time\"] = pd.NaT\n    df[\"waiting_time\"] = 0\n    df[\"tardiness\"] = 0\n\n    current_time = df.iloc[0][\"arrival_time\"]\n\n    for i in range(len(df)):\n        arrival = df.iloc[i][\"arrival_time\"]\n        processing = df.iloc[i][\"processing_time\"]\n        due = df.iloc[i][\"due_date\"]\n\n        start_time = max(current_time, arrival)\n        completion_time = start_time + pd.to_timedelta(processing, unit=\"D\")\n\n        df.loc[df.index[i], \"start_time\"] = start_time\n        df.loc[df.index[i], \"completion_time\"] = completion_time\n        df.loc[df.index[i], \"waiting_time\"] = (start_time - arrival).days\n        df.loc[df.index[i], \"tardiness\"] = max(0, (completion_time - due).days)\n\n        current_time = completion_time\n\n    metrics = {\n        \"Average waiting time\": df[\"waiting_time\"].mean(),\n        \"Average tardiness\": df[\"tardiness\"].mean(),\n        \"Maximum tardiness\": df[\"tardiness\"].max(),\n        \"Late job percentage\": (df[\"tardiness\"] > 0).mean() * 100,\n        \"Makespan (days)\": (df[\"completion_time\"].max() - df[\"arrival_time\"].min()).days\n    }\n\n    return df, metrics\n```\n\n## [**4.5 First Come First Served (FCFS)**]{style=\"color:#990000;\"}\n\n::: {.callout-tip title=\"Algorithm\" icon=\"false\"}\n-   Step 1: Sort all orders by their arrival time from earliest to latest.\n-   Step 2: Select the first order in the list.\n-   Step 3: Start processing the selected order as soon as the machine is available.\n-   Step 4: Complete the order without interruption.\n-   Step 5: Move to the next order in the arrival_time order.\n-   Step 6: Repeat unitl all jobs are processed.\n:::\n\n### FCFS Python Implementation\n\n```{python}\n#| code-fold: true\n#| code-summary: FCFS\n#| code-line-numbers: true\ndef FCFS(df):\n    return df.sort_values(\"arrival_time\").reset_index(drop=True)\n```\n\n## [**4.6 Shortest Processing Time (SPT)**]{style=\"color:#990000;\"}\n\n::: {.callout-tip title=\"Algorithm\" icon=\"false\"}\n-   Step 1: Sort all orders by their processing time from shortest to longest.\n-   Step 2: Select the order with the smallest processing time.\n-   Step 3: Start processing the selected order as soon as the machine is available.\n-   Step 4: Complete the order without interruption.\n-   Step 5: Move to the next order in the processing_time order.\n-   Step 6: Repeat until all jobs are processed.\n:::\n\n### SPT Python Implementation\n\n```{python}\n#| code-fold: true\n#| code-summary: SPT\n#| code-line-numbers: true\ndef SPT(df):\n    return df.sort_values(\"processing_time\").reset_index(drop=True)\n\n```\n\n## [**4.7 Earliest Due Date (EDD)**]{style=\"color:#990000;\"}\n\n::: {.callout-tip title=\"Algorithm\" icon=\"false\"}\n-   Step 1: Sort all orders by their due dates from earliest to latest.\n-   Step 2: Select the order with the earliest due date.\n-   Step 3: Start processing the selected order as soon as the machine is available.\n-   Step 4: Complete the order without interruption.\n-   Step 5: Move to the next order in the due_date order.\n-   Step 6: Repeat until all jobs are processed.\n:::\n\n### EDD Python Implementation\n\n```{python}\n#| code-fold: true\n#| code-summary: EDD\n#| code-line-numbers: true\ndef EDD(df):\n    return df.sort_values(\"due_date\").reset_index(drop=True)\n```\n\n## [**4.8 Example Implementation and Results**]{style=\"color:#990000;\"}\n\nTo illustrate the proposed scheduling framework, three sellers are selected randomly from the dataset. For each seller, a scheduling table is constructed and the FCFS, SPT, and EDD sequencing rules are applied. The resulting schedules are simulated, and performance metrics are computed to compare the impact of each sequencing rule.\n\n```{python}\n#| code-fold: true\n#| code-summary: Randomize Three Seller's IDs \n#| code-line-numbers: true\nimport random\n\nrandom_sellers = random.sample(\n    list(order_items[\"seller_id\"].unique()),\n    3\n)\n\nrandom_sellers\n```\n\n```{python}\n#| code-fold: true\n#| code-summary: perfoming scheduling\n#| code-line-numbers: true\nall_results = {}\n\nfor seller_id in random_sellers:\n    schedule = create_scheduling_table(seller_id, order_items, orders)\n\n    _, fcfs_metrics = simulate_schedule_and_metrics(FCFS(schedule))\n    _, spt_metrics  = simulate_schedule_and_metrics(SPT(schedule))\n    _, edd_metrics  = simulate_schedule_and_metrics(EDD(schedule))\n\n    results_df = pd.DataFrame({\n        \"Metric\": list(fcfs_metrics.keys()),\n        \"FCFS\": list(fcfs_metrics.values()),\n        \"SPT\": list(spt_metrics.values()),\n        \"EDD\": list(edd_metrics.values())\n    })\n\n    results_df[[\"FCFS\", \"SPT\", \"EDD\"]] = results_df[[\"FCFS\", \"SPT\", \"EDD\"]].round(2)\n\n    all_results[seller_id] = results_df\n```\n\n```{python}\n#| code-fold: true \n#| code-summary: results\n#| code-line-numbers: true\n\nfor seller_id, result in all_results.items():\n    print(f\"\\nResults for Seller: {seller_id}\")\n    display(result)\n```\n\nIt is observed that for **some sellers**, all sequencing rules yield **zero waiting time and zero tardiness**. This occurs when sellers have **very few orders or when order arrivals are sufficiently spaced in time**, resulting in no congestion. In such cases, **all jobs begin processing immediately** upon arrival and are completed before their due dates, causing FCFS, SPT, and EDD to behave identically. Meaningful differences between sequencing rules emerge only for sellers with higher order volumes, where competition for processing capacity creates waiting and deadline violations.\n\nIn order **to fix this problem**, we need to **select sellers who have atleast 10 orders**. This way, it supports our model more accuarately.\n\n```{python}\n\"\"\"\n#| code-fold: true \n#| code-summary: Keep only sellers with at least 10 items\n#| code-line-numbers: true\n\n# Count number of items per seller\nseller_item_counts = (\n    order_items\n    .groupby(\"seller_id\")\n    .size()\n    .reset_index(name=\"num_items\")\n)\n\n# Keep only sellers with at least 10 items\nactive_sellers = seller_item_counts[\n    seller_item_counts[\"num_items\"] >= 10\n][\"seller_id\"]\n\nimport random\n\n#random_sellers = random.sample(\n#    list(active_sellers),\n#    3\n#)\n\"\"\"\nrandom_sellers = [\"6560211a19b47992c3666cc44a7e94c0\",\"4a3ca9315b744ce9f8e9374361493884\", \"1f50f920176fa81dab994f9023523100\"]\n```\n\n```{python}\n#| code-fold: true\n#| code-summary: perfoming scheduling\n#| code-line-numbers: true\nall_results = {}\n\nfor seller_id in random_sellers:\n    schedule = create_scheduling_table(seller_id, order_items, orders)\n\n    _, fcfs_metrics = simulate_schedule_and_metrics(FCFS(schedule))\n    _, spt_metrics  = simulate_schedule_and_metrics(SPT(schedule))\n    _, edd_metrics  = simulate_schedule_and_metrics(EDD(schedule))\n\n    results_df = pd.DataFrame({\n        \"Metric\": list(fcfs_metrics.keys()),\n        \"FCFS\": list(fcfs_metrics.values()),\n        \"SPT\": list(spt_metrics.values()),\n        \"EDD\": list(edd_metrics.values())\n    })\n\n    results_df[[\"FCFS\", \"SPT\", \"EDD\"]] = results_df[[\"FCFS\", \"SPT\", \"EDD\"]].round(2)\n\n    all_results[seller_id] = results_df\n```\n\n```{python}\n#| code-fold: true\n#| code-summary: results\n#| code-line-numbers: true\nmetrics_order = [\n    \"Average waiting time\",\n    \"Average tardiness\",\n    \"Maximum tardiness\",\n    \"Late job percentage\",\n    \"Makespan (days)\"\n]\n\ncolors = {\n    \"FCFS\": \"#636EFA\",\n    \"SPT\": \"#EF553B\",\n    \"EDD\": \"#00CC96\"\n}\n\nfor seller_id, df in all_results.items():\n    print(f\"\\nMetrics for Seller {seller_id}\")\n    display(df)\n\n    fig = make_subplots(\n        rows=1,\n        cols=5,\n        horizontal_spacing=0.08\n    )\n\n    for col, metric in enumerate(metrics_order, start=1):\n        row = df[df[\"Metric\"] == metric].iloc[0]\n\n        for method in [\"FCFS\", \"SPT\", \"EDD\"]:\n            fig.add_trace(\n                go.Bar(\n                    x=[method],\n                    y=[row[method]],\n                    name=method,\n                    marker_color=colors[method],\n                    showlegend=(col == 1),\n                    hovertemplate=(\n                        f\"<b>{metric}</b><br>\"\n                        f\"Method: {method}<br>\"\n                        \"Value: %{y:.2f}<extra></extra>\"\n                    )\n                ),\n                row=1,\n                col=col\n            )\n\n        fig.add_annotation(\n            text=f\"<b>{metric}</b>\",\n            xref=\"x domain\",\n            yref=\"paper\",\n            x=0.5,\n            y=1.00,\n            showarrow=False,\n            font=dict(size=14),\n            row=1,\n            col=col\n        )\n\n    fig.update_layout(\n        title=dict(\n            text=f\"Scheduling Performance Comparison — Seller {seller_id}\",\n            x=0.5,\n            y=0.8,\n            xanchor=\"center\",\n            yanchor=\"top\",\n            font=dict(size=20)\n        ),\n        height=500,\n        width=1500,\n        barmode=\"group\",\n        template=\"plotly_white\",\n        margin=dict(t=130, b=80, l=50, r=50),\n        legend=dict(\n            orientation=\"h\",\n            yanchor=\"bottom\",\n            y=-0.25,\n            xanchor=\"center\",\n            x=0.5\n        )\n    )\n\n    fig.update_xaxes(showgrid=False, tickfont=dict(size=11))\n    fig.update_yaxes(gridcolor=\"rgba(0,0,0,0.05)\", tickfont=dict(size=11))\n\n    fig.show()\n```\n\n# [**5. Conculsion**]{style=\"color:#990000;\"}\n\nThis project successfully modeled e-commerce sellers as independent single-machine scheduling systems using the Brazilian Olist dataset. The findings confirm that the impact of sequencing rules is dictated by order volume. For sellers with low or well-spaced order volume, sequencing decisions are irrelevant as no queue forms; however, for high-volume sellers experiencing congestion, the choice of rule (FCFS, SPT, or EDD) has a significant effect on performance measures such as average waiting time and tardiness. Future work may extend this framework by incorporating more realistic processing time models, capacity constraints, or stochastic order arrivals.\n\n# [**6. Interactive System**]{style=\"color:#990000;\"}\n\nThis project includes an interactive Streamlit application where users can input a seller ID and compare FCFS, SPT, and EDD results.\n\n[Seller Order Sequencing Dashboard](https://scheduling-or.streamlit.app)\n\n","srcMarkdownNoYaml":"\n\n# [1. **Introduction**]{style=\"color:#990000;\"}\n\nThis project studies the sequencing of customer orders for a single seller in an e-commerce platform. We compare three classical single-machine scheduling rules, **First Come First Served (FCFS), Shortest Processing Time (SPT), and Earliest Due Date (EDD), and evaluate their effects on waiting time and tardiness.**\n\nUsing the [Brazilian E-Commerce (Olist) dataset](https://www.kaggle.com/datasets/olistbr/brazilian-ecommerce), we simulate order processing for each seller independently and develop an interactive system that allows sellers to input their seller ID and examine the resulting order sequences and performance metrics under each rule.\n\n::: callout-note\nMandatory Tables\n\n-   olist_orders_dataset\n-   olist_order_items_dataset\n:::\n\n# [**2. Objective**]{style=\"color:#990000;\"}\n\nThe main objectives of this project are to:\n\n1.  Model the order processing of a single seller as a single-machine scheduling problem.\n\n2.  Apply and compare three classical sequencing rules: First Come First Served (FCFS), Shortest Processing Time (SPT), and Earliest Due Date (EDD).\n\n3.  Evaluate the impact of each sequencing rule on key performance measures, including waiting time and tardiness.\n\n4.  Use real transaction data from the Brazilian E-Commerce (Olist) dataset to simulate order processing under each rule.\n\n5.  Develop an interactive scheduling system that allows sellers to input their seller ID and analyze order sequences and performance metrics.\n\n# [**3. Road Map**]{style=\"color:#990000;\"}\n\n```{mermaid}\nflowchart LR\n    A(**Data Preprocessing**<br/>Clean data<br/>Understand features) --> B(**Seller Separation**<br/>Group orders by seller<br/>Treat each seller independently)\n    B --> C(**Sequencing Models**<br/>FCFS<br/>SPT<br/>EDD) \n    C --> D(**Interactive System**<br/>Input seller ID<br/>View sequences & metrics)\n```\n\n# [**4. Methodolgy**]{style=\"color:#990000;\"}\n\n## [**4.1 Data Cleaning and Data Preprocessing**]{style=\"color:#990000;\"}\n\n### 4.1.1. Import Important Libraries and Load Data\n\n```{python}\n#| code-fold: true\nimport pandas as pd\nimport numpy as np\nimport plotly.graph_objects as go\nfrom plotly.subplots import make_subplots \n```\n\n```{python}\n#| code-fold: true\n#| code-summary: load order items data\n#| code-line-numbers: true\norder_items = pd.read_csv(\"olist_order_items_dataset.csv\")\norder_items.head()\n```\n\n```{python}\n#| code-fold: true\n#| code-line-numbers: true\norders = pd.read_csv(\"olist_orders_dataset.csv\")\norders.head()\n```\n\n### 4.1.2. Features Understanding\n\nThe following tables summarize the main features used from the olist_order_items_dataset and olist_orders_dataset, including their descriptions and data types. Only variables relevant to order sequencing and scheduling are considered in this project.\n\n```{python}\n#| code-fold: true\n#| code-summary: load orders data\n#| code-line-numbers: true\n\norder_items_features = pd.DataFrame({\n    \"Feature\": [\n        \"order_id\",\n        \"order_item_id\",\n        \"product_id\",\n        \"seller_id\",\n        \"shipping_limit_date\",\n        \"price\",\n        \"freight_value\"\n    ],\n    \"Description\": [\n        \"Unique identifier of an order\",\n        \"Sequential number of the item within the order\",\n        \"Unique identifier of the product\",\n        \"Unique identifier of the seller\",\n        \"Deadline for the seller to ship the item\",\n        \"Price of the item\",\n        \"Shipping cost of the item\"\n    ],\n    \"Data Type\": [\n        \"Categorical (string)\",\n        \"Integer\",\n        \"Categorical (string)\",\n        \"Categorical (string)\",\n        \"Datetime\",\n        \"Numeric (float)\",\n        \"Numeric (float)\"\n    ]\n})\n\norder_items_features\n\n```\n\nThe following tables summarize the main features used from the olist_order_items_dataset and olist_orders_dataset, including their descriptions and data types. Only variables relevant to order sequencing and scheduling are considered in this project.\n\n```{python}\n#| code-fold: true\n#| code-line-numbers: true\n\norders_features = pd.DataFrame({\n    \"Feature\": [\n        \"order_id\",\n        \"customer_id\",\n        \"order_status\",\n        \"order_purchase_timestamp\",\n        \"order_approved_at\",\n        \"order_delivered_carrier_date\",\n        \"order_delivered_customer_date\",\n        \"order_estimated_delivery_date\"\n    ],\n    \"Description\": [\n        \"Unique identifier of an order\",\n        \"Unique identifier of the customer\",\n        \"Current status of the order\",\n        \"Time when the customer placed the order\",\n        \"Time when payment was approved\",\n        \"Time when order was handed to the carrier\",\n        \"Time when order was delivered to customer\",\n        \"Estimated delivery deadline\"\n    ],\n    \"Data Type\": [\n        \"Categorical (string)\",\n        \"Categorical (string)\",\n        \"Categorical\",\n        \"Datetime\",\n        \"Datetime\",\n        \"Datetime\",\n        \"Datetime\",\n        \"Datetime\"\n    ]\n})\n\norders_features\n```\n\nFrom the available features, only variables that directly contribute to modeling a single-machine scheduling problem are retained. Specifically, **seller_id** is used to define independent seller systems, **order_approved_at** represents the **arrival time of an order**, and **order_estimated_delivery_date** serves as the due date (deadline), and the number of items per order is used as a proxy for processing time. Other features are excluded as they do not influence sequencing decisions or scheduling priorities.\n\n## [**4.2. Seller Separation**]{style=\"color:#990000;\"}\n\nThe Olist dataset contains multiple sellers, each operating independently. To model order processing as a single-machine scheduling problem, sellers are first identified and separated so that each seller’s orders form an independent scheduling system.\n\n```{python}\n#| code-fold: true\n#| code-summary: load orders data\n#| code-line-numbers: true\nnum_sellers = order_items[\"seller_id\"].nunique()\nprint(f\"There are a total of {num_sellers} unique sellers.\")\n```\n\nTo analyze order flow at the seller level, orders are grouped by seller_id. For each seller, a scheduling table is constructed where each order is treated as one job. The order purchase time is defined as the arrival time, the estimated delivery date is used as the due date, and the number of items in an order is used as a proxy for processing time.\n\nThe following function generates a scheduling table for any selected seller:\n\n```{python}\n#| code-fold: true\n#| code-summary: load orders data\n#| code-line-numbers: true\n\ndef create_scheduling_table(seller_id, order_items, orders):\n    seller_items = order_items[order_items[\"seller_id\"] == seller_id]\n\n    scheduling_table = (\n        seller_items\n        .merge(orders, on=\"order_id\")\n        .groupby(\"order_id\")\n        .agg(\n            arrival_time=(\"order_approved_at\", \"first\"),\n            due_date=(\"order_estimated_delivery_date\", \"first\"),\n            processing_time=(\"order_item_id\", \"count\")\n        )\n        .reset_index()\n    )\n    return scheduling_table\n\n```\n\nTo ensure meaningful sequencing analysis, sellers are ranked based on the total number of items ordered. This allows the selection of sellers with sufficient order volume.\n\n```{python}\n#| code-fold: true\n#| code-summary: rank sellers by number of items\norders_per_seller_df = (\norder_items\n.groupby(\"seller_id\")\n.size()\n.reset_index(name=\"number_of_items\")\n.sort_values(by=\"number_of_items\", ascending=False)\n)\n\norders_per_seller_df.head()\n```\n\n## [**4.3. Data Cleaning**]{style=\"color:#990000;\"}\n\nBefore applying the sequencing models, the dataset is checked for missing values and data type consistency. In particular, timestamp variables must be converted to datetime format to ensure accurate computation of arrival times, due dates, waiting times, and tardiness.\n\n<<<<<<< HEAD\n### [**4.3.1 Check for Missing Values**]{style=\"color:#990000;\"}\n=======\n[4.3. Data Cleaning]{style=\"color:#990000;\"}\n\nBefore applying the sequencing models, the dataset is checked for missing values and data type consistency. In particular, timestamp variables must be converted to datetime format to ensure accurate computation of arrival times, due dates, waiting times, and tardiness.\n\n4.3.1 Check for Missing Values\n>>>>>>> 73229e2 (Update sequencing_single_seller.qmd and generated site)\n\nThe following code checks for missing values in both datasets.\n\n```{python}\n#| code-fold: true\n#| code-summary: Data Info\n#| code-line-numbers: true\norder_items.isnull().sum()\n```\n\n```{python}\n#| code-fold: true\n#| code-summary: Data Info\n#| code-line-numbers: true\norders.isnull().sum()\n```\n\n```{python}\n#| code-fold: true\n#| code-summary: Removing Missing Values\n#| code-line-numbers: true\n#| \nvalid_orders = orders[orders[\"order_approved_at\"].notna()]\n# Keep only valid orders in orders table\norders_clean = valid_orders.copy()\n\n# Keep only order_items belonging to valid orders\norder_items_clean = order_items[\n    order_items[\"order_id\"].isin(orders_clean[\"order_id\"])\n]\norders_clean = orders_clean.reset_index(drop=True)\norder_items_clean = order_items_clean.reset_index(drop=True)\n\n```\n\n```{python}\n\n#| code-fold: true\n#| code-summary: Data Info\n#| code-line-numbers: true\norders = orders_clean\norder_items = order_items_clean\n```\n\nMoreover, to perform time-based calculations, all relevant date columns are converted to datetime format.\n\n```{python}\n#| code-fold: true\n#| code-summary: Convert to datetime\n#| code-line-numbers: true\norder_items[\"shipping_limit_date\"] = pd.to_datetime(\norder_items[\"shipping_limit_date\"]\n)\n```\n\n```{python}\n#| code-fold: true\n#| code-summary: convert orders date columns\ndate_columns = [\n\"order_purchase_timestamp\",\n\"order_approved_at\",\n\"order_delivered_carrier_date\",\n\"order_delivered_customer_date\",\n\"order_estimated_delivery_date\"\n]\n\nfor col in date_columns:\n    orders[col] = pd.to_datetime(orders[col])\n```\n\nAfter conversion, data types are verified to ensure correctness.\n\n```{python}\n#| code-fold: true\n#| code-summary: verify data types\norders.dtypes\n```\n\n```{python}\n#| code-fold: true\n#| code-summary: verify data types\norder_items.dtypes\n```\n\nAll timestamp variables are now stored as datetime objects, allowing accurate computation of arrival times, due dates, and scheduling performance metrics.\n\n## [**4.4. Sequencing Model Formulation**]{style=\"color:#990000;\"}\n\n### [**4.4.1. Scheduling Variables and Performance Measures**]{style=\"color:#990000;\"}\n\nIn this project, order processing for each seller is modeled as a **single-machine scheduling problem**. Each order is treated as a job that must be processed by a single server (the seller), with **no preemption** and **only one job processed at a time**.\n\n### Scheduling Variables\n\nFor each order (job) $i$, the following scheduling variables are defined:\n\n-   **Arrival time ($r_i$)**\\\n    The time at which order $i$ becomes available for processing.\\\n    In this study, $r_i$ is defined as the **order_approved_at**.\n\n-   **Processing time ($p_i$)**\\\n    The time required to complete order $i$.\\\n    Since actual handling times are unavailable, $p_i$ is approximated by the **number of items in the order**.\n\n-   **Due date ($d_i$)**\\\n    The promised completion time for order $i$.\\\n    This is defined as the **estimated delivery date** provided by the platform.\n\n-   **Sequence (π)**\\\n    An ordered list of jobs that specifies the processing order, determined by a sequencing rule such as **FCFS**, **SPT**, or **EDD**.\n\n### Performance Measures\n\nTo evaluate the effectiveness of each sequencing rule, the following standard performance measures are used:\n\n-   **Start time ($S_i$)**\\\n    The time at which processing of order $i$ begins.\n\n-   **Completion time ($C_i$)**\\\n    The time at which processing of order $i$ finishes.\n\n-   **Waiting time ($W_i$)**\\\n    The amount of time order $i$ waits before processing:\n\n    $$\n    W_i = S_i - r_i\n    $$\n\n-   **Tardiness ($T_i$)**\\\n    The amount by which order *i* is completed after its due date:\n\n    $$\n    T_i = \\max(0, C_i - d_i)\n    $$\n\nThese performance measures are commonly used in single-machine scheduling problems and allow for a quantitative comparison of different sequencing rules in terms of service efficiency and deadline compliance.\n\n### [**4.4.2 Schedule Simulation Procedure**]{style=\"color:#990000;\"}\n\nOnce a processing sequence is determined by a sequencing rule, the order processing schedule is simulated using standard single-machine scheduling logic. Given a fixed sequence of jobs, start times, completion times, waiting times, and tardiness values are computed sequentially.\n\nLet jobs be indexed according to the chosen sequence. For each order (job) $i$, processing begins either when the previous job is completed or when the order arrives, whichever occurs later. The start time is therefore defined as:\n\n$$\nS_i = \\max(C_{i-1}, r_i)\n$$\n\nThe completion time of job $i$ is then given by:\n\n$$\nC_i = S_i + p_i\n$$\n\nUsing the computed start and completion times, performance measures are obtained as follows. The waiting time of job $i$ is defined as the difference between its start time and arrival time:\n\n$$\nW_i = S_i - r_i\n$$\n\nThe tardiness of job $i$ measures the extent to which completion exceeds the due date and is defined as:\n\n$$\nT_i = \\max(0, C_i - d_i)\n$$\n\nThis simulation procedure is applied uniformly across all sequencing rules. By holding the simulation logic constant and varying only the job sequence, the impact of different sequencing rules on waiting time and tardiness can be fairly and consistently compared.\n\n```{python}\n#| code-fold: false\n#| code-summary: simulate schedule\n#| code-line-numbers: true\ndef simulate_schedule_and_metrics(df):\n    df = df.copy()\n    df[\"start_time\"] = pd.NaT\n    df[\"completion_time\"] = pd.NaT\n    df[\"waiting_time\"] = 0\n    df[\"tardiness\"] = 0\n\n    current_time = df.iloc[0][\"arrival_time\"]\n\n    for i in range(len(df)):\n        arrival = df.iloc[i][\"arrival_time\"]\n        processing = df.iloc[i][\"processing_time\"]\n        due = df.iloc[i][\"due_date\"]\n\n        start_time = max(current_time, arrival)\n        completion_time = start_time + pd.to_timedelta(processing, unit=\"D\")\n\n        df.loc[df.index[i], \"start_time\"] = start_time\n        df.loc[df.index[i], \"completion_time\"] = completion_time\n        df.loc[df.index[i], \"waiting_time\"] = (start_time - arrival).days\n        df.loc[df.index[i], \"tardiness\"] = max(0, (completion_time - due).days)\n\n        current_time = completion_time\n\n    metrics = {\n        \"Average waiting time\": df[\"waiting_time\"].mean(),\n        \"Average tardiness\": df[\"tardiness\"].mean(),\n        \"Maximum tardiness\": df[\"tardiness\"].max(),\n        \"Late job percentage\": (df[\"tardiness\"] > 0).mean() * 100,\n        \"Makespan (days)\": (df[\"completion_time\"].max() - df[\"arrival_time\"].min()).days\n    }\n\n    return df, metrics\n```\n\n## [**4.5 First Come First Served (FCFS)**]{style=\"color:#990000;\"}\n\n::: {.callout-tip title=\"Algorithm\" icon=\"false\"}\n-   Step 1: Sort all orders by their arrival time from earliest to latest.\n-   Step 2: Select the first order in the list.\n-   Step 3: Start processing the selected order as soon as the machine is available.\n-   Step 4: Complete the order without interruption.\n-   Step 5: Move to the next order in the arrival_time order.\n-   Step 6: Repeat unitl all jobs are processed.\n:::\n\n### FCFS Python Implementation\n\n```{python}\n#| code-fold: true\n#| code-summary: FCFS\n#| code-line-numbers: true\ndef FCFS(df):\n    return df.sort_values(\"arrival_time\").reset_index(drop=True)\n```\n\n## [**4.6 Shortest Processing Time (SPT)**]{style=\"color:#990000;\"}\n\n::: {.callout-tip title=\"Algorithm\" icon=\"false\"}\n-   Step 1: Sort all orders by their processing time from shortest to longest.\n-   Step 2: Select the order with the smallest processing time.\n-   Step 3: Start processing the selected order as soon as the machine is available.\n-   Step 4: Complete the order without interruption.\n-   Step 5: Move to the next order in the processing_time order.\n-   Step 6: Repeat until all jobs are processed.\n:::\n\n### SPT Python Implementation\n\n```{python}\n#| code-fold: true\n#| code-summary: SPT\n#| code-line-numbers: true\ndef SPT(df):\n    return df.sort_values(\"processing_time\").reset_index(drop=True)\n\n```\n\n## [**4.7 Earliest Due Date (EDD)**]{style=\"color:#990000;\"}\n\n::: {.callout-tip title=\"Algorithm\" icon=\"false\"}\n-   Step 1: Sort all orders by their due dates from earliest to latest.\n-   Step 2: Select the order with the earliest due date.\n-   Step 3: Start processing the selected order as soon as the machine is available.\n-   Step 4: Complete the order without interruption.\n-   Step 5: Move to the next order in the due_date order.\n-   Step 6: Repeat until all jobs are processed.\n:::\n\n### EDD Python Implementation\n\n```{python}\n#| code-fold: true\n#| code-summary: EDD\n#| code-line-numbers: true\ndef EDD(df):\n    return df.sort_values(\"due_date\").reset_index(drop=True)\n```\n\n## [**4.8 Example Implementation and Results**]{style=\"color:#990000;\"}\n\nTo illustrate the proposed scheduling framework, three sellers are selected randomly from the dataset. For each seller, a scheduling table is constructed and the FCFS, SPT, and EDD sequencing rules are applied. The resulting schedules are simulated, and performance metrics are computed to compare the impact of each sequencing rule.\n\n```{python}\n#| code-fold: true\n#| code-summary: Randomize Three Seller's IDs \n#| code-line-numbers: true\nimport random\n\nrandom_sellers = random.sample(\n    list(order_items[\"seller_id\"].unique()),\n    3\n)\n\nrandom_sellers\n```\n\n```{python}\n#| code-fold: true\n#| code-summary: perfoming scheduling\n#| code-line-numbers: true\nall_results = {}\n\nfor seller_id in random_sellers:\n    schedule = create_scheduling_table(seller_id, order_items, orders)\n\n    _, fcfs_metrics = simulate_schedule_and_metrics(FCFS(schedule))\n    _, spt_metrics  = simulate_schedule_and_metrics(SPT(schedule))\n    _, edd_metrics  = simulate_schedule_and_metrics(EDD(schedule))\n\n    results_df = pd.DataFrame({\n        \"Metric\": list(fcfs_metrics.keys()),\n        \"FCFS\": list(fcfs_metrics.values()),\n        \"SPT\": list(spt_metrics.values()),\n        \"EDD\": list(edd_metrics.values())\n    })\n\n    results_df[[\"FCFS\", \"SPT\", \"EDD\"]] = results_df[[\"FCFS\", \"SPT\", \"EDD\"]].round(2)\n\n    all_results[seller_id] = results_df\n```\n\n```{python}\n#| code-fold: true \n#| code-summary: results\n#| code-line-numbers: true\n\nfor seller_id, result in all_results.items():\n    print(f\"\\nResults for Seller: {seller_id}\")\n    display(result)\n```\n\nIt is observed that for **some sellers**, all sequencing rules yield **zero waiting time and zero tardiness**. This occurs when sellers have **very few orders or when order arrivals are sufficiently spaced in time**, resulting in no congestion. In such cases, **all jobs begin processing immediately** upon arrival and are completed before their due dates, causing FCFS, SPT, and EDD to behave identically. Meaningful differences between sequencing rules emerge only for sellers with higher order volumes, where competition for processing capacity creates waiting and deadline violations.\n\nIn order **to fix this problem**, we need to **select sellers who have atleast 10 orders**. This way, it supports our model more accuarately.\n\n```{python}\n\"\"\"\n#| code-fold: true \n#| code-summary: Keep only sellers with at least 10 items\n#| code-line-numbers: true\n\n# Count number of items per seller\nseller_item_counts = (\n    order_items\n    .groupby(\"seller_id\")\n    .size()\n    .reset_index(name=\"num_items\")\n)\n\n# Keep only sellers with at least 10 items\nactive_sellers = seller_item_counts[\n    seller_item_counts[\"num_items\"] >= 10\n][\"seller_id\"]\n\nimport random\n\n#random_sellers = random.sample(\n#    list(active_sellers),\n#    3\n#)\n\"\"\"\nrandom_sellers = [\"6560211a19b47992c3666cc44a7e94c0\",\"4a3ca9315b744ce9f8e9374361493884\", \"1f50f920176fa81dab994f9023523100\"]\n```\n\n```{python}\n#| code-fold: true\n#| code-summary: perfoming scheduling\n#| code-line-numbers: true\nall_results = {}\n\nfor seller_id in random_sellers:\n    schedule = create_scheduling_table(seller_id, order_items, orders)\n\n    _, fcfs_metrics = simulate_schedule_and_metrics(FCFS(schedule))\n    _, spt_metrics  = simulate_schedule_and_metrics(SPT(schedule))\n    _, edd_metrics  = simulate_schedule_and_metrics(EDD(schedule))\n\n    results_df = pd.DataFrame({\n        \"Metric\": list(fcfs_metrics.keys()),\n        \"FCFS\": list(fcfs_metrics.values()),\n        \"SPT\": list(spt_metrics.values()),\n        \"EDD\": list(edd_metrics.values())\n    })\n\n    results_df[[\"FCFS\", \"SPT\", \"EDD\"]] = results_df[[\"FCFS\", \"SPT\", \"EDD\"]].round(2)\n\n    all_results[seller_id] = results_df\n```\n\n```{python}\n#| code-fold: true\n#| code-summary: results\n#| code-line-numbers: true\nmetrics_order = [\n    \"Average waiting time\",\n    \"Average tardiness\",\n    \"Maximum tardiness\",\n    \"Late job percentage\",\n    \"Makespan (days)\"\n]\n\ncolors = {\n    \"FCFS\": \"#636EFA\",\n    \"SPT\": \"#EF553B\",\n    \"EDD\": \"#00CC96\"\n}\n\nfor seller_id, df in all_results.items():\n    print(f\"\\nMetrics for Seller {seller_id}\")\n    display(df)\n\n    fig = make_subplots(\n        rows=1,\n        cols=5,\n        horizontal_spacing=0.08\n    )\n\n    for col, metric in enumerate(metrics_order, start=1):\n        row = df[df[\"Metric\"] == metric].iloc[0]\n\n        for method in [\"FCFS\", \"SPT\", \"EDD\"]:\n            fig.add_trace(\n                go.Bar(\n                    x=[method],\n                    y=[row[method]],\n                    name=method,\n                    marker_color=colors[method],\n                    showlegend=(col == 1),\n                    hovertemplate=(\n                        f\"<b>{metric}</b><br>\"\n                        f\"Method: {method}<br>\"\n                        \"Value: %{y:.2f}<extra></extra>\"\n                    )\n                ),\n                row=1,\n                col=col\n            )\n\n        fig.add_annotation(\n            text=f\"<b>{metric}</b>\",\n            xref=\"x domain\",\n            yref=\"paper\",\n            x=0.5,\n            y=1.00,\n            showarrow=False,\n            font=dict(size=14),\n            row=1,\n            col=col\n        )\n\n    fig.update_layout(\n        title=dict(\n            text=f\"Scheduling Performance Comparison — Seller {seller_id}\",\n            x=0.5,\n            y=0.8,\n            xanchor=\"center\",\n            yanchor=\"top\",\n            font=dict(size=20)\n        ),\n        height=500,\n        width=1500,\n        barmode=\"group\",\n        template=\"plotly_white\",\n        margin=dict(t=130, b=80, l=50, r=50),\n        legend=dict(\n            orientation=\"h\",\n            yanchor=\"bottom\",\n            y=-0.25,\n            xanchor=\"center\",\n            x=0.5\n        )\n    )\n\n    fig.update_xaxes(showgrid=False, tickfont=dict(size=11))\n    fig.update_yaxes(gridcolor=\"rgba(0,0,0,0.05)\", tickfont=dict(size=11))\n\n    fig.show()\n```\n\n# [**5. Conculsion**]{style=\"color:#990000;\"}\n\nThis project successfully modeled e-commerce sellers as independent single-machine scheduling systems using the Brazilian Olist dataset. The findings confirm that the impact of sequencing rules is dictated by order volume. For sellers with low or well-spaced order volume, sequencing decisions are irrelevant as no queue forms; however, for high-volume sellers experiencing congestion, the choice of rule (FCFS, SPT, or EDD) has a significant effect on performance measures such as average waiting time and tardiness. Future work may extend this framework by incorporating more realistic processing time models, capacity constraints, or stochastic order arrivals.\n\n# [**6. Interactive System**]{style=\"color:#990000;\"}\n\nThis project includes an interactive Streamlit application where users can input a seller ID and compare FCFS, SPT, and EDD results.\n\n[Seller Order Sequencing Dashboard](https://scheduling-or.streamlit.app)\n\n"},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"engine":"jupyter"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":true,"code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","css":["styles.css"],"toc":true,"toc-depth":2,"output-file":"sequencing_single_seller.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","other-links-title":"Other Links","code-links-title":"Code Links","launch-dev-container-title":"Launch Dev Container","launch-binder-title":"Launch Binder","article-notebook-label":"Article Notebook","notebook-preview-download":"Download Notebook","notebook-preview-download-src":"Download Source","notebook-preview-back":"Back to Article","manuscript-meca-bundle":"MECA Bundle","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","appendix-view-license":"View License","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","title-block-keywords":"Keywords","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","tools-share":"Share","tools-download":"Download","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-text-placeholder":"","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-wordcount":"Word Count","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items","listing-page-words":"{0} words","listing-page-filter":"Filter","draft":"Draft"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.8.26","title":"Sequencing (Single Seller)","author":"Chhouk Phalthunin, Hok Lyhour, Hun Sopheak","mermaid":{"theme":"default"},"theme":"cosmo","mathjax":true,"code-summary":"Show code"},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}