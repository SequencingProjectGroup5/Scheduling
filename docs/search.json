[
  {
    "objectID": "sequencing_single_seller.html",
    "href": "sequencing_single_seller.html",
    "title": "Sequencing (Single Seller)",
    "section": "",
    "text": "This project studies the sequencing of customer orders for a single seller in an e-commerce platform. We compare three classical single-machine scheduling rules, First Come First Served (FCFS), Shortest Processing Time (SPT), and Earliest Due Date (EDD), and evaluate their effects on waiting time and tardiness.\nUsing the Brazilian E-Commerce (Olist) dataset, we simulate order processing for each seller independently and develop an interactive system that allows sellers to input their seller ID and examine the resulting order sequences and performance metrics under each rule.\n\n\n\n\n\n\nNote\n\n\n\nMandatory Tables\n\nolist_orders_dataset\nolist_order_items_dataset"
  },
  {
    "objectID": "sequencing_single_seller.html#data-cleaning-and-data-preprocessing",
    "href": "sequencing_single_seller.html#data-cleaning-and-data-preprocessing",
    "title": "Sequencing (Single Seller)",
    "section": "4.1 Data Cleaning and Data Preprocessing",
    "text": "4.1 Data Cleaning and Data Preprocessing\n\n4.1.1. Import Important Libraries and Load Data\n\n\nShow code\nimport pandas as pd\nimport numpy as np\nimport plotly.graph_objects as go\nfrom plotly.subplots import make_subplots \n\n\n\n\nload order items data\norder_items = pd.read_csv(\"olist_order_items_dataset.csv\")\norder_items.head()\n\n\n\n\n\n\n\n\n\norder_id\norder_item_id\nproduct_id\nseller_id\nshipping_limit_date\nprice\nfreight_value\n\n\n\n\n0\n00010242fe8c5a6d1ba2dd792cb16214\n1\n4244733e06e7ecb4970a6e2683c13e61\n48436dade18ac8b2bce089ec2a041202\n2017-09-19 09:45:35\n58.90\n13.29\n\n\n1\n00018f77f2f0320c557190d7a144bdd3\n1\ne5f2d52b802189ee658865ca93d83a8f\ndd7ddc04e1b6c2c614352b383efe2d36\n2017-05-03 11:05:13\n239.90\n19.93\n\n\n2\n000229ec398224ef6ca0657da4fc703e\n1\nc777355d18b72b67abbeef9df44fd0fd\n5b51032eddd242adc84c38acab88f23d\n2018-01-18 14:48:30\n199.00\n17.87\n\n\n3\n00024acbcdf0a6daa1e931b038114c75\n1\n7634da152a4610f1595efa32f14722fc\n9d7a1d34a5052409006425275ba1c2b4\n2018-08-15 10:10:18\n12.99\n12.79\n\n\n4\n00042b26cf59d7ce69dfabb4e55b4fd9\n1\nac6c3623068f30de03045865e4e10089\ndf560393f3a51e74553ab94004ba5c87\n2017-02-13 13:57:51\n199.90\n18.14\n\n\n\n\n\n\n\n\n\nShow code\norders = pd.read_csv(\"olist_orders_dataset.csv\")\norders.head()\n\n\n\n\n\n\n\n\n\norder_id\ncustomer_id\norder_status\norder_purchase_timestamp\norder_approved_at\norder_delivered_carrier_date\norder_delivered_customer_date\norder_estimated_delivery_date\n\n\n\n\n0\ne481f51cbdc54678b7cc49136f2d6af7\n9ef432eb6251297304e76186b10a928d\ndelivered\n2017-10-02 10:56:33\n2017-10-02 11:07:15\n2017-10-04 19:55:00\n2017-10-10 21:25:13\n2017-10-18 00:00:00\n\n\n1\n53cdb2fc8bc7dce0b6741e2150273451\nb0830fb4747a6c6d20dea0b8c802d7ef\ndelivered\n2018-07-24 20:41:37\n2018-07-26 03:24:27\n2018-07-26 14:31:00\n2018-08-07 15:27:45\n2018-08-13 00:00:00\n\n\n2\n47770eb9100c2d0c44946d9cf07ec65d\n41ce2a54c0b03bf3443c3d931a367089\ndelivered\n2018-08-08 08:38:49\n2018-08-08 08:55:23\n2018-08-08 13:50:00\n2018-08-17 18:06:29\n2018-09-04 00:00:00\n\n\n3\n949d5b44dbf5de918fe9c16f97b45f8a\nf88197465ea7920adcdbec7375364d82\ndelivered\n2017-11-18 19:28:06\n2017-11-18 19:45:59\n2017-11-22 13:39:59\n2017-12-02 00:28:42\n2017-12-15 00:00:00\n\n\n4\nad21c59c0840e6cb83a9ceb5573f8159\n8ab97904e6daea8866dbdbc4fb7aad2c\ndelivered\n2018-02-13 21:18:39\n2018-02-13 22:20:29\n2018-02-14 19:46:34\n2018-02-16 18:17:02\n2018-02-26 00:00:00\n\n\n\n\n\n\n\n\n\n4.1.2. Features Understanding\nThe following tables summarize the main features used from the olist_order_items_dataset and olist_orders_dataset, including their descriptions and data types. Only variables relevant to order sequencing and scheduling are considered in this project.\n\n\nload orders data\norder_items_features = pd.DataFrame({\n    \"Feature\": [\n        \"order_id\",\n        \"order_item_id\",\n        \"product_id\",\n        \"seller_id\",\n        \"shipping_limit_date\",\n        \"price\",\n        \"freight_value\"\n    ],\n    \"Description\": [\n        \"Unique identifier of an order\",\n        \"Sequential number of the item within the order\",\n        \"Unique identifier of the product\",\n        \"Unique identifier of the seller\",\n        \"Deadline for the seller to ship the item\",\n        \"Price of the item\",\n        \"Shipping cost of the item\"\n    ],\n    \"Data Type\": [\n        \"Categorical (string)\",\n        \"Integer\",\n        \"Categorical (string)\",\n        \"Categorical (string)\",\n        \"Datetime\",\n        \"Numeric (float)\",\n        \"Numeric (float)\"\n    ]\n})\n\norder_items_features\n\n\n\n\n\n\n\n\n\nFeature\nDescription\nData Type\n\n\n\n\n0\norder_id\nUnique identifier of an order\nCategorical (string)\n\n\n1\norder_item_id\nSequential number of the item within the order\nInteger\n\n\n2\nproduct_id\nUnique identifier of the product\nCategorical (string)\n\n\n3\nseller_id\nUnique identifier of the seller\nCategorical (string)\n\n\n4\nshipping_limit_date\nDeadline for the seller to ship the item\nDatetime\n\n\n5\nprice\nPrice of the item\nNumeric (float)\n\n\n6\nfreight_value\nShipping cost of the item\nNumeric (float)\n\n\n\n\n\n\n\nThe following tables summarize the main features used from the olist_order_items_dataset and olist_orders_dataset, including their descriptions and data types. Only variables relevant to order sequencing and scheduling are considered in this project.\n\n\nShow code\norders_features = pd.DataFrame({\n    \"Feature\": [\n        \"order_id\",\n        \"customer_id\",\n        \"order_status\",\n        \"order_purchase_timestamp\",\n        \"order_approved_at\",\n        \"order_delivered_carrier_date\",\n        \"order_delivered_customer_date\",\n        \"order_estimated_delivery_date\"\n    ],\n    \"Description\": [\n        \"Unique identifier of an order\",\n        \"Unique identifier of the customer\",\n        \"Current status of the order\",\n        \"Time when the customer placed the order\",\n        \"Time when payment was approved\",\n        \"Time when order was handed to the carrier\",\n        \"Time when order was delivered to customer\",\n        \"Estimated delivery deadline\"\n    ],\n    \"Data Type\": [\n        \"Categorical (string)\",\n        \"Categorical (string)\",\n        \"Categorical\",\n        \"Datetime\",\n        \"Datetime\",\n        \"Datetime\",\n        \"Datetime\",\n        \"Datetime\"\n    ]\n})\n\norders_features\n\n\n\n\n\n\n\n\n\nFeature\nDescription\nData Type\n\n\n\n\n0\norder_id\nUnique identifier of an order\nCategorical (string)\n\n\n1\ncustomer_id\nUnique identifier of the customer\nCategorical (string)\n\n\n2\norder_status\nCurrent status of the order\nCategorical\n\n\n3\norder_purchase_timestamp\nTime when the customer placed the order\nDatetime\n\n\n4\norder_approved_at\nTime when payment was approved\nDatetime\n\n\n5\norder_delivered_carrier_date\nTime when order was handed to the carrier\nDatetime\n\n\n6\norder_delivered_customer_date\nTime when order was delivered to customer\nDatetime\n\n\n7\norder_estimated_delivery_date\nEstimated delivery deadline\nDatetime\n\n\n\n\n\n\n\nFrom the available features, only variables that directly contribute to modeling a single-machine scheduling problem are retained. Specifically, seller_id is used to define independent seller systems, order_approved_at represents the arrival time of an order, and order_estimated_delivery_date serves as the due date (deadline), and the number of items per order is used as a proxy for processing time. Other features are excluded as they do not influence sequencing decisions or scheduling priorities."
  },
  {
    "objectID": "sequencing_single_seller.html#seller-separation",
    "href": "sequencing_single_seller.html#seller-separation",
    "title": "Sequencing (Single Seller)",
    "section": "4.2. Seller Separation",
    "text": "4.2. Seller Separation\nThe Olist dataset contains multiple sellers, each operating independently. To model order processing as a single-machine scheduling problem, sellers are first identified and separated so that each seller’s orders form an independent scheduling system.\n\n\nload orders data\nnum_sellers = order_items[\"seller_id\"].nunique()\nprint(f\"There are a total of {num_sellers} unique sellers.\")\n\n\nThere are a total of 3095 unique sellers.\n\n\nTo analyze order flow at the seller level, orders are grouped by seller_id. For each seller, a scheduling table is constructed where each order is treated as one job. The order purchase time is defined as the arrival time, the estimated delivery date is used as the due date, and the number of items in an order is used as a proxy for processing time.\nThe following function generates a scheduling table for any selected seller:\n\n\nload orders data\ndef create_scheduling_table(seller_id, order_items, orders):\n    seller_items = order_items[order_items[\"seller_id\"] == seller_id]\n\n    scheduling_table = (\n        seller_items\n        .merge(orders, on=\"order_id\")\n        .groupby(\"order_id\")\n        .agg(\n            arrival_time=(\"order_approved_at\", \"first\"),\n            due_date=(\"order_estimated_delivery_date\", \"first\"),\n            processing_time=(\"order_item_id\", \"count\")\n        )\n        .reset_index()\n    )\n    return scheduling_table\n\n\nTo ensure meaningful sequencing analysis, sellers are ranked based on the total number of items ordered. This allows the selection of sellers with sufficient order volume.\n\n\nrank sellers by number of items\norders_per_seller_df = (\norder_items\n.groupby(\"seller_id\")\n.size()\n.reset_index(name=\"number_of_items\")\n.sort_values(by=\"number_of_items\", ascending=False)\n)\n\norders_per_seller_df.head()\n\n\n\n\n\n\n\n\n\nseller_id\nnumber_of_items\n\n\n\n\n1235\n6560211a19b47992c3666cc44a7e94c0\n2033\n\n\n881\n4a3ca9315b744ce9f8e9374361493884\n1987\n\n\n368\n1f50f920176fa81dab994f9023523100\n1931\n\n\n2481\ncc419e0650a3c5ba77189a1882b7556a\n1775\n\n\n2643\nda8622b14eb17ae2831f4ac5b9dab84a\n1551"
  },
  {
    "objectID": "sequencing_single_seller.html#data-cleaning",
    "href": "sequencing_single_seller.html#data-cleaning",
    "title": "Sequencing (Single Seller)",
    "section": "4.3. Data Cleaning",
    "text": "4.3. Data Cleaning\nBefore applying the sequencing models, the dataset is checked for missing values and data type consistency. In particular, timestamp variables must be converted to datetime format to ensure accurate computation of arrival times, due dates, waiting times, and tardiness.\nGreat, this fits perfectly as Section 4.3 Data Cleaning. Below is a clean, concise, and well-structured 4.3 section, with clear explanations and correct Python code that you can paste directly into your Quarto document.\n4.3. Data Cleaning\nBefore applying the sequencing models, the dataset is checked for missing values and data type consistency. In particular, timestamp variables must be converted to datetime format to ensure accurate computation of arrival times, due dates, waiting times, and tardiness.\n4.3.1 Check for Missing Values\nThe following code checks for missing values in both datasets.\n\n\nData Info\norder_items.isnull().sum()\n\n\norder_id               0\norder_item_id          0\nproduct_id             0\nseller_id              0\nshipping_limit_date    0\nprice                  0\nfreight_value          0\ndtype: int64\n\n\n\n\nData Info\norders.isnull().sum()\n\n\norder_id                            0\ncustomer_id                         0\norder_status                        0\norder_purchase_timestamp            0\norder_approved_at                 160\norder_delivered_carrier_date     1783\norder_delivered_customer_date    2965\norder_estimated_delivery_date       0\ndtype: int64\n\n\n\n\nRemoving Missing Values\nvalid_orders = orders[orders[\"order_approved_at\"].notna()]\n# Keep only valid orders in orders table\norders_clean = valid_orders.copy()\n\n# Keep only order_items belonging to valid orders\norder_items_clean = order_items[\n    order_items[\"order_id\"].isin(orders_clean[\"order_id\"])\n]\norders_clean = orders_clean.reset_index(drop=True)\norder_items_clean = order_items_clean.reset_index(drop=True)\n\n\n\n\nData Info\norders = orders_clean\norder_items = order_items_clean\n\n\nMoreover, to perform time-based calculations, all relevant date columns are converted to datetime format.\n\n\nConvert to datetime\norder_items[\"shipping_limit_date\"] = pd.to_datetime(\norder_items[\"shipping_limit_date\"]\n)\n\n\n\n\nconvert orders date columns\ndate_columns = [\n\"order_purchase_timestamp\",\n\"order_approved_at\",\n\"order_delivered_carrier_date\",\n\"order_delivered_customer_date\",\n\"order_estimated_delivery_date\"\n]\n\nfor col in date_columns:\n    orders[col] = pd.to_datetime(orders[col])\n\n\nAfter conversion, data types are verified to ensure correctness.\n\n\nverify data types\norders.dtypes\n\n\norder_id                                 object\ncustomer_id                              object\norder_status                             object\norder_purchase_timestamp         datetime64[ns]\norder_approved_at                datetime64[ns]\norder_delivered_carrier_date     datetime64[ns]\norder_delivered_customer_date    datetime64[ns]\norder_estimated_delivery_date    datetime64[ns]\ndtype: object\n\n\n\n\nverify data types\norder_items.dtypes\n\n\norder_id                       object\norder_item_id                   int64\nproduct_id                     object\nseller_id                      object\nshipping_limit_date    datetime64[ns]\nprice                         float64\nfreight_value                 float64\ndtype: object\n\n\nAll timestamp variables are now stored as datetime objects, allowing accurate computation of arrival times, due dates, and scheduling performance metrics."
  },
  {
    "objectID": "sequencing_single_seller.html#sequencing-model-formulation",
    "href": "sequencing_single_seller.html#sequencing-model-formulation",
    "title": "Sequencing (Single Seller)",
    "section": "4.4. Sequencing Model Formulation",
    "text": "4.4. Sequencing Model Formulation\n\n4.4.1. Scheduling Variables and Performance Measures\nIn this project, order processing for each seller is modeled as a single-machine scheduling problem. Each order is treated as a job that must be processed by a single server (the seller), with no preemption and only one job processed at a time.\n\n\nScheduling Variables\nFor each order (job) \\(i\\), the following scheduling variables are defined:\n\nArrival time (\\(r_i\\))\nThe time at which order \\(i\\) becomes available for processing.\nIn this study, \\(r_i\\) is defined as the order_approved_at.\nProcessing time (\\(p_i\\))\nThe time required to complete order \\(i\\).\nSince actual handling times are unavailable, \\(p_i\\) is approximated by the number of items in the order.\nDue date (\\(d_i\\))\nThe promised completion time for order \\(i\\).\nThis is defined as the estimated delivery date provided by the platform.\nSequence (π)\nAn ordered list of jobs that specifies the processing order, determined by a sequencing rule such as FCFS, SPT, or EDD.\n\n\n\nPerformance Measures\nTo evaluate the effectiveness of each sequencing rule, the following standard performance measures are used:\n\nStart time (\\(S_i\\))\nThe time at which processing of order \\(i\\) begins.\nCompletion time (\\(C_i\\))\nThe time at which processing of order \\(i\\) finishes.\nWaiting time (\\(W_i\\))\nThe amount of time order \\(i\\) waits before processing:\n\\[\nW_i = S_i - r_i\n\\]\nTardiness (\\(T_i\\))\nThe amount by which order i is completed after its due date:\n\\[\nT_i = \\max(0, C_i - d_i)\n\\]\n\nThese performance measures are commonly used in single-machine scheduling problems and allow for a quantitative comparison of different sequencing rules in terms of service efficiency and deadline compliance.\n\n\n4.4.2 Schedule Simulation Procedure\nOnce a processing sequence is determined by a sequencing rule, the order processing schedule is simulated using standard single-machine scheduling logic. Given a fixed sequence of jobs, start times, completion times, waiting times, and tardiness values are computed sequentially.\nLet jobs be indexed according to the chosen sequence. For each order (job) \\(i\\), processing begins either when the previous job is completed or when the order arrives, whichever occurs later. The start time is therefore defined as:\n\\[\nS_i = \\max(C_{i-1}, r_i)\n\\]\nThe completion time of job \\(i\\) is then given by:\n\\[\nC_i = S_i + p_i\n\\]\nUsing the computed start and completion times, performance measures are obtained as follows. The waiting time of job \\(i\\) is defined as the difference between its start time and arrival time:\n\\[\nW_i = S_i - r_i\n\\]\nThe tardiness of job \\(i\\) measures the extent to which completion exceeds the due date and is defined as:\n\\[\nT_i = \\max(0, C_i - d_i)\n\\]\nThis simulation procedure is applied uniformly across all sequencing rules. By holding the simulation logic constant and varying only the job sequence, the impact of different sequencing rules on waiting time and tardiness can be fairly and consistently compared.\n\ndef simulate_schedule_and_metrics(df):\n    df = df.copy()\n    df[\"start_time\"] = pd.NaT\n    df[\"completion_time\"] = pd.NaT\n    df[\"waiting_time\"] = 0\n    df[\"tardiness\"] = 0\n\n    current_time = df.iloc[0][\"arrival_time\"]\n\n    for i in range(len(df)):\n        arrival = df.iloc[i][\"arrival_time\"]\n        processing = df.iloc[i][\"processing_time\"]\n        due = df.iloc[i][\"due_date\"]\n\n        start_time = max(current_time, arrival)\n        completion_time = start_time + pd.to_timedelta(processing, unit=\"D\")\n\n        df.loc[df.index[i], \"start_time\"] = start_time\n        df.loc[df.index[i], \"completion_time\"] = completion_time\n        df.loc[df.index[i], \"waiting_time\"] = (start_time - arrival).days\n        df.loc[df.index[i], \"tardiness\"] = max(0, (completion_time - due).days)\n\n        current_time = completion_time\n\n    metrics = {\n        \"Average waiting time\": df[\"waiting_time\"].mean(),\n        \"Average tardiness\": df[\"tardiness\"].mean(),\n        \"Maximum tardiness\": df[\"tardiness\"].max(),\n        \"Late job percentage\": (df[\"tardiness\"] &gt; 0).mean() * 100,\n        \"Makespan (days)\": (df[\"completion_time\"].max() - df[\"arrival_time\"].min()).days\n    }\n\n    return df, metrics"
  },
  {
    "objectID": "sequencing_single_seller.html#first-come-first-served-fcfs",
    "href": "sequencing_single_seller.html#first-come-first-served-fcfs",
    "title": "Sequencing (Single Seller)",
    "section": "4.5 First Come First Served (FCFS)",
    "text": "4.5 First Come First Served (FCFS)\n\n\n\n\n\n\nTipAlgorithm\n\n\n\n\nStep 1: Sort all orders by their arrival time from earliest to latest.\nStep 2: Select the first order in the list.\nStep 3: Start processing the selected order as soon as the machine is available.\nStep 4: Complete the order without interruption.\nStep 5: Move to the next order in the arrival_time order.\nStep 6: Repeat unitl all jobs are processed.\n\n\n\n\nFCFS Python Implementation\n\n\nFCFS\ndef FCFS(df):\n    return df.sort_values(\"arrival_time\").reset_index(drop=True)"
  },
  {
    "objectID": "sequencing_single_seller.html#shortest-processing-time-spt",
    "href": "sequencing_single_seller.html#shortest-processing-time-spt",
    "title": "Sequencing (Single Seller)",
    "section": "4.6 Shortest Processing Time (SPT)",
    "text": "4.6 Shortest Processing Time (SPT)\n\n\n\n\n\n\nTipAlgorithm\n\n\n\n\nStep 1: Sort all orders by their processing time from shortest to longest.\nStep 2: Select the order with the smallest processing time.\nStep 3: Start processing the selected order as soon as the machine is available.\nStep 4: Complete the order without interruption.\nStep 5: Move to the next order in the processing_time order.\nStep 6: Repeat until all jobs are processed.\n\n\n\n\nSPT Python Implementation\n\n\nSPT\ndef SPT(df):\n    return df.sort_values(\"processing_time\").reset_index(drop=True)"
  },
  {
    "objectID": "sequencing_single_seller.html#earliest-due-date-edd",
    "href": "sequencing_single_seller.html#earliest-due-date-edd",
    "title": "Sequencing (Single Seller)",
    "section": "4.7 Earliest Due Date (EDD)",
    "text": "4.7 Earliest Due Date (EDD)\n\n\n\n\n\n\nTipAlgorithm\n\n\n\n\nStep 1: Sort all orders by their due dates from earliest to latest.\nStep 2: Select the order with the earliest due date.\nStep 3: Start processing the selected order as soon as the machine is available.\nStep 4: Complete the order without interruption.\nStep 5: Move to the next order in the due_date order.\nStep 6: Repeat until all jobs are processed.\n\n\n\n\nEDD Python Implementation\n\n\nEDD\ndef EDD(df):\n    return df.sort_values(\"due_date\").reset_index(drop=True)"
  },
  {
    "objectID": "sequencing_single_seller.html#example-implementation-and-results",
    "href": "sequencing_single_seller.html#example-implementation-and-results",
    "title": "Sequencing (Single Seller)",
    "section": "4.8 Example Implementation and Results",
    "text": "4.8 Example Implementation and Results\nTo illustrate the proposed scheduling framework, three sellers are selected randomly from the dataset. For each seller, a scheduling table is constructed and the FCFS, SPT, and EDD sequencing rules are applied. The resulting schedules are simulated, and performance metrics are computed to compare the impact of each sequencing rule.\n\n\nRandomize Three Seller’s IDs\nimport random\n\nrandom_sellers = random.sample(\n    list(order_items[\"seller_id\"].unique()),\n    3\n)\n\nrandom_sellers\n\n\n['41958cbd3335433c8740300e8cd600d5',\n '6f1a1263039c76e68f40a8e536b1da6a',\n '0df3984f9dfb3d49ac6366acbd3bbb85']\n\n\n\n\nperfoming scheduling\nall_results = {}\n\nfor seller_id in random_sellers:\n    schedule = create_scheduling_table(seller_id, order_items, orders)\n\n    _, fcfs_metrics = simulate_schedule_and_metrics(FCFS(schedule))\n    _, spt_metrics  = simulate_schedule_and_metrics(SPT(schedule))\n    _, edd_metrics  = simulate_schedule_and_metrics(EDD(schedule))\n\n    results_df = pd.DataFrame({\n        \"Metric\": list(fcfs_metrics.keys()),\n        \"FCFS\": list(fcfs_metrics.values()),\n        \"SPT\": list(spt_metrics.values()),\n        \"EDD\": list(edd_metrics.values())\n    })\n\n    results_df[[\"FCFS\", \"SPT\", \"EDD\"]] = results_df[[\"FCFS\", \"SPT\", \"EDD\"]].round(2)\n\n    all_results[seller_id] = results_df\n\n\n\n\nresults\nfor seller_id, result in all_results.items():\n    print(f\"\\nResults for Seller: {seller_id}\")\n    display(result)\n\n\n\nResults for Seller: 41958cbd3335433c8740300e8cd600d5\n\n\n\n\n\n\n\n\n\nMetric\nFCFS\nSPT\nEDD\n\n\n\n\n0\nAverage waiting time\n0.0\n0.0\n0.0\n\n\n1\nAverage tardiness\n0.0\n0.0\n0.0\n\n\n2\nMaximum tardiness\n0.0\n0.0\n0.0\n\n\n3\nLate job percentage\n0.0\n0.0\n0.0\n\n\n4\nMakespan (days)\n1.0\n1.0\n1.0\n\n\n\n\n\n\n\n\nResults for Seller: 6f1a1263039c76e68f40a8e536b1da6a\n\n\n\n\n\n\n\n\n\nMetric\nFCFS\nSPT\nEDD\n\n\n\n\n0\nAverage waiting time\n0.0\n31.0\n0.75\n\n\n1\nAverage tardiness\n0.0\n27.0\n0.00\n\n\n2\nMaximum tardiness\n0.0\n108.0\n0.00\n\n\n3\nLate job percentage\n0.0\n25.0\n0.00\n\n\n4\nMakespan (days)\n120.0\n125.0\n121.00\n\n\n\n\n\n\n\n\nResults for Seller: 0df3984f9dfb3d49ac6366acbd3bbb85\n\n\n\n\n\n\n\n\n\nMetric\nFCFS\nSPT\nEDD\n\n\n\n\n0\nAverage waiting time\n0.46\n199.74\n3.85\n\n\n1\nAverage tardiness\n0.00\n179.63\n0.00\n\n\n2\nMaximum tardiness\n0.00\n454.00\n0.00\n\n\n3\nLate job percentage\n0.00\n89.66\n0.00\n\n\n4\nMakespan (days)\n464.00\n516.00\n464.00\n\n\n\n\n\n\n\nIt is observed that for some sellers, all sequencing rules yield zero waiting time and zero tardiness. This occurs when sellers have very few orders or when order arrivals are sufficiently spaced in time, resulting in no congestion. In such cases, all jobs begin processing immediately upon arrival and are completed before their due dates, causing FCFS, SPT, and EDD to behave identically. Meaningful differences between sequencing rules emerge only for sellers with higher order volumes, where competition for processing capacity creates waiting and deadline violations.\nIn order to fix this problem, we need to select sellers who have atleast 10 orders. This way, it supports our model more accuarately.\n\n\nShow code\n\"\"\"\n#| code-fold: true \n#| code-summary: Keep only sellers with at least 10 items\n#| code-line-numbers: true\n\n# Count number of items per seller\nseller_item_counts = (\n    order_items\n    .groupby(\"seller_id\")\n    .size()\n    .reset_index(name=\"num_items\")\n)\n\n# Keep only sellers with at least 10 items\nactive_sellers = seller_item_counts[\n    seller_item_counts[\"num_items\"] &gt;= 10\n][\"seller_id\"]\n\nimport random\n\n#random_sellers = random.sample(\n#    list(active_sellers),\n#    3\n#)\n\"\"\"\nrandom_sellers = [\"6560211a19b47992c3666cc44a7e94c0\",\"4a3ca9315b744ce9f8e9374361493884\", \"1f50f920176fa81dab994f9023523100\"]\n\n\n\n\nperfoming scheduling\nall_results = {}\n\nfor seller_id in random_sellers:\n    schedule = create_scheduling_table(seller_id, order_items, orders)\n\n    _, fcfs_metrics = simulate_schedule_and_metrics(FCFS(schedule))\n    _, spt_metrics  = simulate_schedule_and_metrics(SPT(schedule))\n    _, edd_metrics  = simulate_schedule_and_metrics(EDD(schedule))\n\n    results_df = pd.DataFrame({\n        \"Metric\": list(fcfs_metrics.keys()),\n        \"FCFS\": list(fcfs_metrics.values()),\n        \"SPT\": list(spt_metrics.values()),\n        \"EDD\": list(edd_metrics.values())\n    })\n\n    results_df[[\"FCFS\", \"SPT\", \"EDD\"]] = results_df[[\"FCFS\", \"SPT\", \"EDD\"]].round(2)\n\n    all_results[seller_id] = results_df\n\n\n\n\nresults\nmetrics_order = [\n    \"Average waiting time\",\n    \"Average tardiness\",\n    \"Maximum tardiness\",\n    \"Late job percentage\",\n    \"Makespan (days)\"\n]\n\ncolors = {\n    \"FCFS\": \"#636EFA\",\n    \"SPT\": \"#EF553B\",\n    \"EDD\": \"#00CC96\"\n}\n\nfor seller_id, df in all_results.items():\n    print(f\"\\nMetrics for Seller {seller_id}\")\n    display(df)\n\n    fig = make_subplots(\n        rows=1,\n        cols=5,\n        horizontal_spacing=0.08\n    )\n\n    for col, metric in enumerate(metrics_order, start=1):\n        row = df[df[\"Metric\"] == metric].iloc[0]\n\n        for method in [\"FCFS\", \"SPT\", \"EDD\"]:\n            fig.add_trace(\n                go.Bar(\n                    x=[method],\n                    y=[row[method]],\n                    name=method,\n                    marker_color=colors[method],\n                    showlegend=(col == 1),\n                    hovertemplate=(\n                        f\"&lt;b&gt;{metric}&lt;/b&gt;&lt;br&gt;\"\n                        f\"Method: {method}&lt;br&gt;\"\n                        \"Value: %{y:.2f}&lt;extra&gt;&lt;/extra&gt;\"\n                    )\n                ),\n                row=1,\n                col=col\n            )\n\n        fig.add_annotation(\n            text=f\"&lt;b&gt;{metric}&lt;/b&gt;\",\n            xref=\"x domain\",\n            yref=\"paper\",\n            x=0.5,\n            y=1.00,\n            showarrow=False,\n            font=dict(size=14),\n            row=1,\n            col=col\n        )\n\n    fig.update_layout(\n        title=dict(\n            text=f\"Scheduling Performance Comparison — Seller {seller_id}\",\n            x=0.5,\n            y=0.8,\n            xanchor=\"center\",\n            yanchor=\"top\",\n            font=dict(size=20)\n        ),\n        height=500,\n        width=1500,\n        barmode=\"group\",\n        template=\"plotly_white\",\n        margin=dict(t=130, b=80, l=50, r=50),\n        legend=dict(\n            orientation=\"h\",\n            yanchor=\"bottom\",\n            y=-0.25,\n            xanchor=\"center\",\n            x=0.5\n        )\n    )\n\n    fig.update_xaxes(showgrid=False, tickfont=dict(size=11))\n    fig.update_yaxes(gridcolor=\"rgba(0,0,0,0.05)\", tickfont=dict(size=11))\n\n    fig.show()\n\n\n\nMetrics for Seller 6560211a19b47992c3666cc44a7e94c0\n\n\n\n\n\n\n\n\n\nMetric\nFCFS\nSPT\nEDD\n\n\n\n\n0\nAverage waiting time\n687.69\n1138.14\n693.19\n\n\n1\nAverage tardiness\n669.06\n1119.05\n674.73\n\n\n2\nMaximum tardiness\n1479.00\n2490.00\n1466.00\n\n\n3\nLate job percentage\n97.30\n99.78\n97.79\n\n\n4\nMakespan (days)\n2040.00\n2578.00\n2045.00\n\n\n\n\n\n\n\n                                                \n\n\n\nMetrics for Seller 4a3ca9315b744ce9f8e9374361493884\n\n\n\n\n\n\n\n\n\nMetric\nFCFS\nSPT\nEDD\n\n\n\n\n0\nAverage waiting time\n699.30\n1162.85\n706.00\n\n\n1\nAverage tardiness\n678.42\n1140.82\n685.01\n\n\n2\nMaximum tardiness\n1397.00\n2394.00\n1400.00\n\n\n3\nLate job percentage\n96.40\n99.78\n96.95\n\n\n4\nMakespan (days)\n2001.00\n2549.00\n2007.00\n\n\n\n\n\n\n\n                                                \n\n\n\nMetrics for Seller 1f50f920176fa81dab994f9023523100\n\n\n\n\n\n\n\n\n\nMetric\nFCFS\nSPT\nEDD\n\n\n\n\n0\nAverage waiting time\n749.03\n945.21\n751.87\n\n\n1\nAverage tardiness\n726.42\n922.12\n728.72\n\n\n2\nMaximum tardiness\n1479.00\n2219.00\n1476.00\n\n\n3\nLate job percentage\n96.15\n99.29\n96.51\n\n\n4\nMakespan (days)\n1996.00\n2400.00\n1999.00"
  }
]